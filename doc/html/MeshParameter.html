<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CRheoLAB: Mesh parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "amssymb.js", "amsmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="crheoLogo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CRheoLAB<span id="projectnumber">&#160;version 0.0</span>
   </div>
   <div id="projectbrief">CRheoLAB solver for learning CFD</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('MeshParameter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="classMesh.html">Mesh</a> parameters </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><ul><li class="level3"><a href="#autotoc_md2">Face Area</a></li>
<li class="level3"><a href="#autotoc_md4">Face Area Vector</a></li>
<li class="level3"><a href="#autotoc_md6">Face Weighting Factor</a></li>
<li class="level3"><a href="#autotoc_md8">Cell Volume and Center of Mass</a></li>
<li class="level3"><a href="#autotoc_md10">Face and Cell Skewness</a></li>
<li class="level3"><a href="#autotoc_md12">Non-Orthogonality</a></li>
<li class="level3"><a href="#autotoc_md13">Non-Orthogonality Computation for Interior Faces</a></li>
<li class="level3"><a href="#autotoc_md14">Non-Orthogonality Computation – Boundary Faces</a></li>
</ul>
</ul>
</ul>
</div>
<div class="textblock"><hr  />
<p >This page is dedicated to the derivation of mesh parameters.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Face Area</h3>
<p >line1</p>
<p >line2</p>
<p >line3</p>
<hr  />
 <h3><a class="anchor" id="autotoc_md4"></a>
Face Area Vector</h3>
<p >For the calculation of the face area vector \(\vec{S}_f\) will utilize the face area ( \(S_f\) ) results given in <a href="#face-area">click on this link</a>.</p>
<p >The normal to a surface is defined as a vector which is perpendicular to the surface at a given point. In CFD we are interested in two quantities: the unitary face surface normal \(\vec{n}_f\) and the face area vector \(\vec{S}_f\) .</p>
<p >Figure X depicts the procedured used to calculate the face unit normal.</p>
<div class="image">
<object type="image/svg+xml" data="fav_1.svg" width="350px" style="pointer-events: none;"></object>
<div class="caption">
Figure 1: Calculation of the face unit normal vector</div></div>
<p >A vector \(\vec{v}_3\), perpendicular to the face is calculated from the cross-product between the first two consecutive points that compose a face and the face's center of mass. Afterwards, the normal unit vector is calculated by doing the ratio between the vector \(\vec{v}_3\) and its norm.</p>
<p >The calculation of the surface area vector is finnalized by multiplying the face area with the face normal unit vector.</p>
<div class="image">
<object type="image/svg+xml" data="fav_2.svg" width="350px" style="pointer-events: none;"></object>
<div class="caption">
Figure 2: Calculation of the face area vector</div></div>
<p >By definition the surface unit normal always points outwards from the face. However due to storage requirements, in CRheoLAB as in <a href="https://www.openfoam.com/">OpenFOAM(R)</a>, we will just store the final direction of the face area vector. We will consider \(\vec{S}_f\) to be positive if it points from the owner cell to the neighobour cell, and negative if it points in the other direction.</p>
<div class="image">
<object type="image/svg+xml" data="fav_3.svg" width="350px" style="pointer-events: none;"></object>
<div class="caption">
Figure 2: Direction of the face area vector</div></div>
<p >To this end, the dot product between the vector that connects the center of the owner cell and the neighbour cell \(\vec{d}_{ON}\) and the face area vector. If the operation is positive, \(\vec{S}_f\) is pointing in the correct diction. If the value is negative, \(\vec{S}_f\) is multiplied with a scalar of value -1 to correct its direction.</p>
<p >For more details, please refer to <a class="el" href="classFace.html#a1a230cbbca325d32a59fd5d05d26f69e" title="Computes the face area vector .">Face::computeAreaVector()</a> .</p>
<hr  />
 <h3><a class="anchor" id="autotoc_md6"></a>
Face Weighting Factor</h3>
<p >The documentation for this topic is adapted from <b>[Moukalled2015]</b>.</p>
<p >The discretization of the gradient of a property, e.g. \(\phi\) at the cell centroids and faces is fundamental to construct the discretized set of equations for the diffusion and convection terms.</p>
<p >How to do the weighting? Consider the one dimensional ﬁnite volume mesh system shown in Figure FWF1.</p>
<div class="image">
<img src="linearInterpolation.png" alt="" width="450px"/>
<div class="caption">
Figure FWF1: Linear Face weighting factor.</div></div>
<p >The values of \(\phi\) are known at the control volume centroids \(C\) and \(F\), and are to be used to compute the value of \(\phi\) at the interface \(f\) between these cells.</p>
<p >A simple linear interpolation will result in the following equation:</p>
<p class="formulaDsp">
\[ \phi_{f}=g_{f}\phi_{F}+\left(1-g_{f}\right)\phi_{C} \]
</p>
<p >Where,</p>
<p class="formulaDsp">
\[ g_{f}=\frac{\vec{d}_{Cf}}{\vec{d}_{Cf}+\vec{d}_{fF}} \]
</p>
<p >On the other hand the calculation can be also done by the next equation.</p>
<p class="formulaDsp">
\[ \phi_{f}=g_{c}\phi_{C}+\left(1-g_{c}\right)\phi_{F} \]
</p>
<p >Where,</p>
<p class="formulaDsp">
\[ g_{c}=\frac{\vec{d}_{fF}}{\vec{d}_{Cf}+\vec{d}_{fF}} \]
</p>
<p >The simplicity of this formula does not extend into multi-dimensional situations, as in two or three dimensions, the circumstances become a bit more complicated. In this case, there is not a unique option for the definition of the geometric weighting factors.</p>
<p >One choice would be to base the weighting factor on the respective volumes, such that:</p>
<p class="formulaDsp">
\[ g_{f}=\frac{V_{C}}{V_{C}+V_{F}} \]
</p>
<p >This however yields wrong results in certain cases, as the Figure FWF2 is illustrating.</p>
<div class="image">
<img src="meshInterpolationsSpecial.png" alt="" width="650px"/>
<div class="caption">
Figure FWF2: Other mesh types which needs special attention to Face weighting factor.</div></div>
<p >A better alternative for such cases, is to base the interpolation on the normal distances to the face \(f\).</p>
<p >Then the interpolation based on the normal distances to the face \(f\) is computed as:</p>
<p class="formulaDsp">
\[ g_{f}=\frac{\vec{d}_{Cf}\cdot \vec{e}_{f}}{ \vec{d}_{Cf} \cdot \vec{e}_{f}+ \vec{d}_{fF} \cdot \vec{e}_{f}} ; \vec{e}_{f}=\frac{ \vec{S}_{f}}{\left\| \vec{S}_{f}\right\|} \]
</p>
<p >where these parameters used for the calculations are presented in Figure FWF3.</p>
<div class="image">
<img src="generalFaceWeightingFactor.png" alt="" width="750px"/>
<div class="caption">
Figure FWF3: General Face Weighting Factor parameters.</div></div>
<p >In CRheolab we use the same procedure as in <a href="https://www.openfoam.com/">OpenFOAM(R)</a>, which is centered on the Neighbour cell with:</p>
<p class="formulaDsp">
\[ g_{c}=\frac{ \left | \vec{d}_{fF} \cdot \vec{S}_f \right | }{ \left | \vec{d}_{Cf} \cdot \vec{S}_f \right | + \left | \vec{d}_{fF} \cdot \vec{S}_f \right |} \]
</p>
<p >This implementation is carried out in <a class="el" href="classFace.html#a93a8eb18180b2c5387226b4c24ee4fbb" title="Computation of cells face weighting factor, .">Face::computeWeightingFactor()</a></p>
<dl class="section note"><dt>Note</dt><dd>\(g_{f} = 1 - g_{C}\)</dd></dl>
<hr  />
 <h3><a class="anchor" id="autotoc_md8"></a>
Cell Volume and Center of Mass</h3>
<p >For each cell of the mesh there is the necessity of compute the cell volume and center of mass.</p>
<p >Firstly, the methodology behind the computation of each cell volume is built over the following steps:</p>
<ol type="1">
<li><p class="startli">Compute the geometric centre \(X_G\) of each cell</p>
<p class="formulaDsp">
\[ X_G = \frac{1}{k} \sum^k_{i=1}X_i \]
</p>
 <pre class="fragment">where k stands for the number of vertices in each cell. This step is implement in Cell::computeGeometricCenter(). 
</pre></li>
<li>Decompose each cell into pyramids (Figure CCV1) where:<ul>
<li>The number of pyramids is equal to the number of faces</li>
<li>The apex of each pyramid is the geometric centre of the cell</li>
</ul>
</li>
</ol>
<div class="image">
<object type="image/svg+xml" data="i1.svg" width="550px" style="pointer-events: none;"></object>
<div class="caption">
Figure CCV1: Decomposition of a Polyhedron cell into Pyramids</div></div>
<ol type="1">
<li><p class="startli">Calculate the volume \(V_{pyr}\) of each pyramid</p>
<p class="formulaDsp">
\[ V_{pyr} = \frac{1}{3} d_{Gf}.\vec{S}_f \]
</p>
 <pre class="fragment">This step is implement in Cell::computepyrVol(). 
</pre></li>
<li><p class="startli">Compute the volume of each cell \(V_C \) as the sum of the volumes of all pyramids</p>
<p class="formulaDsp">
\[ V_C = \sum_{\sim Sub-pyramids} V_{pyr} \]
</p>
 <pre class="fragment">This step is implement in Cell::computeVolume(). 
</pre></li>
</ol>
<p >The computation of the center of mass \(X_C\) of each cell can be done by the subsequent steps:</p>
<ol type="1">
<li><p class="startli">Compute the geometric centre \((X_{CE})_{pyr}\) of each of the pyramids</p>
<p class="formulaDsp">
\[ (X_{CE})_{pyr} = 0.75(X_{CE})_f + 0.25(X_G)_{pyr} \]
</p>
</li>
<li><p class="startli">The cell centroid \(X_G\) is equal to the weighted mean of the centroids of the pyramids:</p>
<p class="formulaDsp">
\[ X_C = \frac{\sum_{\sim Sub-pyramids}(X_{CE})_{pyr}V_{pyr}}{V_C} \]
</p>
</li>
</ol>
<p >The computation of \(X_C\) is implemented in <a class="el" href="classCell.html#a5423c88a81ecced77c599ae2b99caa14">Cell::computeCenter()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Notice that the centroid has the same coordinates as the center of mass, since the cell is homogeneous.</dd></dl>
<hr  />
 <h3><a class="anchor" id="autotoc_md10"></a>
Face and Cell Skewness</h3>
<p >By definiton the <a class="el" href="classFace.html">Face</a> Skewness is a measure of the distance between the face center of mass ( \(\vec{F}_{cm}\)) and the face point that corresponds to the intersection \(\vec{F}_{i}\) of the face and the line that:</p><ul>
<li><b>For Interior Faces</b>: joins the center of masses of the cells that share the face, owner \(\vec{O}_{cm}\) and neighbour \(\vec{N}_{cm}\);</li>
<li><b>For boundary Faces</b>: is normal to the face and intersects the boundary (Owner) cell center of mass \(\vec{O}_{cm}\).</li>
</ul>
<p >This will give the Skewness Vector, \(\vec{S}_{kw}\), (See Figure XX)</p>
<div class="image">
<img src="FaceIntPt.png" alt="" width="550px"/>
<div class="caption">
Figure XX: Face Intersection Point and Skewness Vector</div></div>
<p >Then the actual Skewness, \(S_{kw}\), value is obtained by a normalization, as:</p>
<p class="formulaDsp">
\[ S_{kw}=\frac{\| \vec{S}_{kw} \|}{M} \]
</p>
<p >where \(M\) is the maximum magnitude of the following quantities:</p><ul>
<li><b>For Interior Faces</b>: \(0.2 \| \vec{O}_{cm} \vec{N}_{cm} \|\);</li>
<li><b>For boundary Faces</b>: \(0.4 \| \vec{O}_{cm} \vec{F}_{i} \|\);</li>
<li>Projection of the vector that connects the <a class="el" href="classFace.html">Face</a> center of mass, \( \vec{F_{cm}}\), with each of the <a class="el" href="classFace.html">Face</a> Points, \(\vec{P}_{i}\), on the direction of the Skewness Vector, \(\vec{S}_{kw}\), for all the <a class="el" href="classFace.html">Face</a> Points (see Figure YY). For more details, please refer to <a class="el" href="classFace.html#ab6aaaa27bc48d42c68bf2033b7aae801">Face::computeSkewness()</a></li>
</ul>
<div class="image">
<img src="PtProj.png" alt="" width="550px"/>
<div class="caption">
Figure YY: Projection of Vector that connects the Face center of mass with the Face Points on the Direction of the Skewness Vector</div></div>
<p >Finnaly the Owner and Neighbour (for interior faces) cells skewness should be updated with the maximum of the value just calculated and the current cell value. This way, the cell skewness will be equal to the maximum skewness of the faces that comprise it. For more details, please refer to <a class="el" href="classCell.html#a88666c226e29859e543c8eaef36414a3">Cell::computeSkewness()</a>.</p>
<hr  />
 <h3><a class="anchor" id="autotoc_md12"></a>
Non-Orthogonality</h3>
<p >The non-orthogonality of a mesh is defined as the angle made by the vector joining two adjacent cell centers across their common face \(\vec{d}\) and the face normal \(\hat{n}\).</p>
<p >A vector perpendicular to the face shared by both cells creates an angle θ in relation to the vector connecting the centre of mass of the Owner cell \(c_o\) and the neighbor cell \(c_n\). This is the Non-Orthogonality angle \(\theta\).</p>
<p >The Non-orthonality angle is computed in two different ways based on the location of the cell in the domain:</p><ol type="1">
<li>Non-Orthogonality Computation for Interior Faces</li>
<li>Non-Orthogonality Computation for <a class="el" href="classBoundary.html">Boundary</a> Faces <div class="image">
<object type="image/svg+xml" data="cellNonOrtho.svg" width="600px" style="pointer-events: none;"></object>
<div class="caption">
Figure 1: Cell Non-orthogonality</div></div>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md13"></a>
Non-Orthogonality Computation for Interior Faces</h3>
<p >For the interior faces</p>
<div class="image">
<object type="image/svg+xml" data="iFaceOT.svg" width="450px" style="pointer-events: none;"></object>
<div class="caption">
Figure 2: Interior Faces</div></div>
<p >If the cell is an interior one, the Non-orthogonality angle is calculated as follows:</p>
<p ><a class="el" href="classFace.html">Face</a> Area vector:</p>
<p class="formulaDsp">
\[ \vec{d} = c_n - c_o \]
</p>
<p >Calculation of Unit <a class="el" href="classFace.html">Face</a> normal vector:</p>
<p class="formulaDsp">
\[ \vec{n}_{f} = \frac{\vec{S}_{f}}{| \vec{S}_{f}|} \]
</p>
<p >Calculation for the non-orthogonality angle in Radian:</p>
<p class="formulaDsp">
\[ θ = \arccos \left( \frac{\ \vec{d}\cdot \vec{n}_{f} }{|\vec{d}|\cdot |\vec{n}_{f}|} \right) \]
</p>
<p >Where,</p>
<p >\(\vec{S}_{f}\) = Surface Normal Vector</p>
<p >\(\vec{n}_{f}\) = Unit Surface Normal Vector</p>
<p >\(\theta\) = Non-Orthogonality Angle in Radians</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Non-Orthogonality Computation – Boundary Faces</h3>
<p >If the cell is located at the boundary as shown in the following figure</p>
<div class="image">
<object type="image/svg+xml" data="fcOT.svg" width="400px" style="pointer-events: none;"></object>
<div class="caption">
Figure 3: Boundary Faces</div></div>
<p >Where,</p>
<p >\(\vec{d}\) = Vector from <a class="el" href="classCell.html">Cell</a> Owner Centre of Mass to <a class="el" href="classFace.html">Face</a> Centre of <a class="el" href="classBoundary.html">Boundary</a> face</p>
<p >\(c_f\) = <a class="el" href="classFace.html">Face</a> Centre of <a class="el" href="classBoundary.html">Boundary</a> face</p>
<p >\(c_o\) = Centre of Mass of The Owner <a class="el" href="classCell.html">Cell</a></p>
<p ><a class="el" href="classFace.html">Face</a> Area vector:</p>
<p class="formulaDsp">
\[ \vec{d}_{n} = c_f- c_o \]
</p>
<p >Calculation of Unit <a class="el" href="classFace.html">Face</a> normal vector:</p>
<p class="formulaDsp">
\[ \vec{n}_{f} = \frac{\vec{S}_{f}}{| \vec{S}_{f}|} \]
</p>
<p >Calculation for the non-orthogonality angle in Radian:</p>
<p class="formulaDsp">
\[ \theta = \arccos \left( \frac{\ \vec{d}_{n}\cdot\vec{n}_{f}\ }{|\vec{d}_{n}|\cdot |\vec{n}_{f}|} \right) \]
</p>
<p >Where,</p>
<p >\(\vec{S}_{f}\) = Surface Normal Vector</p>
<p >\(\vec{n}_{f}\)=Unit Surface Normal Vector</p>
<p >\(\theta\) = Non- Orthogonality Angle in Radians</p>
<p >For more details, please refer to <a class="el" href="classFace.html#a2d4cf4519725e64a6b95e0fcaa589ea6">Face::computeNonOrthogonality()</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
